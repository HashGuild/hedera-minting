/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import BN from "bn.js";
import { EventData, PastEventOptions } from "web3-eth-contract";

export interface IHederaTokenServiceContract
  extends Truffle.Contract<IHederaTokenServiceInstance> {
  "new"(
    meta?: Truffle.TransactionDetails
  ): Promise<IHederaTokenServiceInstance>;
}

type AllEvents = never;

export interface IHederaTokenServiceInstance extends Truffle.ContractInstance {
  cryptoTransfer: {
    (
      tokenTransfers: {
        token: string;
        transfers: { accountID: string; amount: number | BN | string }[];
        nftTransfers: {
          senderAccountID: string;
          receiverAccountID: string;
          serialNumber: number | BN | string;
        }[];
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      tokenTransfers: {
        token: string;
        transfers: { accountID: string; amount: number | BN | string }[];
        nftTransfers: {
          senderAccountID: string;
          receiverAccountID: string;
          serialNumber: number | BN | string;
        }[];
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      tokenTransfers: {
        token: string;
        transfers: { accountID: string; amount: number | BN | string }[];
        nftTransfers: {
          senderAccountID: string;
          receiverAccountID: string;
          serialNumber: number | BN | string;
        }[];
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      tokenTransfers: {
        token: string;
        transfers: { accountID: string; amount: number | BN | string }[];
        nftTransfers: {
          senderAccountID: string;
          receiverAccountID: string;
          serialNumber: number | BN | string;
        }[];
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Mints an amount of the token to the defined treasury account
   * @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.               Amount must be a positive non-zero number represented in the lowest denomination of the               token. The new supply must be lower than 2^63.
   * @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.                 Maximum allowed size of each metadata is 100 bytes
   * @param token The token for which to mint tokens. If token does not exist, transaction results in              INVALID_TOKEN_ID
   */
  mintToken: {
    (
      token: string,
      amount: number | BN | string,
      metadata: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      amount: number | BN | string,
      metadata: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<{ 0: BN; 1: BN; 2: BN[] }>;
    sendTransaction(
      token: string,
      amount: number | BN | string,
      metadata: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      amount: number | BN | string,
      metadata: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Burns an amount of the token from the defined treasury account
   * @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.                Amount must be a positive non-zero number, not bigger than the token balance of the treasury                account (0; balance], represented in the lowest denomination.
   * @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.
   * @param token The token for which to burn tokens. If token does not exist, transaction results in              INVALID_TOKEN_ID
   */
  burnToken: {
    (
      token: string,
      amount: number | BN | string,
      serialNumbers: (number | BN | string)[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      amount: number | BN | string,
      serialNumbers: (number | BN | string)[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<{ 0: BN; 1: BN }>;
    sendTransaction(
      token: string,
      amount: number | BN | string,
      serialNumbers: (number | BN | string)[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      amount: number | BN | string,
      serialNumbers: (number | BN | string)[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Associates the provided account with the provided tokens. Must be signed by the provided  Account's key or called from the accounts contract key  If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.  If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.  If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.  If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.  If an association between the provided account and any of the tokens already exists, the  transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.  If the provided account's associations count exceed the constraint of maximum token associations    per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.  On success, associations between the provided account and tokens are made and the account is    ready to interact with the tokens.
   * @param account The account to be associated with the provided tokens
   * @param tokens The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE               Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that               token type
   */
  associateTokens: {
    (
      account: string,
      tokens: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      account: string,
      tokens: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      account: string,
      tokens: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      account: string,
      tokens: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Single-token variant of associateTokens. Will be mapped to a single entry array call of associateTokens
   * @param account The account to be associated with the provided token
   * @param token The token to be associated with the provided account
   */
  associateToken: {
    (
      account: string,
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      account: string,
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      account: string,
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      account: string,
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Dissociates the provided account with the provided tokens. Must be signed by the provided Account's key. If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID. If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED. If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF. If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED. If an association between the provided account and any of the tokens does not exist, the transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT. If a token has not been deleted and has not expired, and the user has a nonzero balance, the transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES. If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is not zero. If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES. On success, associations between the provided account and tokens are removed.
   * @param account The account to be dissociated from the provided tokens
   * @param tokens The tokens to be dissociated from the provided account.
   */
  dissociateTokens: {
    (
      account: string,
      tokens: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      account: string,
      tokens: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      account: string,
      tokens: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      account: string,
      tokens: string[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Single-token variant of dissociateTokens. Will be mapped to a single entry array call of dissociateTokens
   * @param account The account to be associated with the provided token
   * @param token The token to be associated with the provided account
   */
  dissociateToken: {
    (
      account: string,
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      account: string,
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      account: string,
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      account: string,
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  createFungibleToken: {
    (
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      initialTotalSupply: number | BN | string,
      decimals: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      initialTotalSupply: number | BN | string,
      decimals: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{ 0: BN; 1: string }>;
    sendTransaction(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      initialTotalSupply: number | BN | string,
      decimals: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      initialTotalSupply: number | BN | string,
      decimals: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  createFungibleTokenWithCustomFees: {
    (
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      initialTotalSupply: number | BN | string,
      decimals: number | BN | string,
      fixedFees: {
        amount: number | BN | string;
        tokenId: string;
        useHbarsForPayment: boolean;
        useCurrentTokenForPayment: boolean;
        feeCollector: string;
      }[],
      fractionalFees: {
        numerator: number | BN | string;
        denominator: number | BN | string;
        minimumAmount: number | BN | string;
        maximumAmount: number | BN | string;
        netOfTransfers: boolean;
        feeCollector: string;
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      initialTotalSupply: number | BN | string,
      decimals: number | BN | string,
      fixedFees: {
        amount: number | BN | string;
        tokenId: string;
        useHbarsForPayment: boolean;
        useCurrentTokenForPayment: boolean;
        feeCollector: string;
      }[],
      fractionalFees: {
        numerator: number | BN | string;
        denominator: number | BN | string;
        minimumAmount: number | BN | string;
        maximumAmount: number | BN | string;
        netOfTransfers: boolean;
        feeCollector: string;
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<{ 0: BN; 1: string }>;
    sendTransaction(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      initialTotalSupply: number | BN | string,
      decimals: number | BN | string,
      fixedFees: {
        amount: number | BN | string;
        tokenId: string;
        useHbarsForPayment: boolean;
        useCurrentTokenForPayment: boolean;
        feeCollector: string;
      }[],
      fractionalFees: {
        numerator: number | BN | string;
        denominator: number | BN | string;
        minimumAmount: number | BN | string;
        maximumAmount: number | BN | string;
        netOfTransfers: boolean;
        feeCollector: string;
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      initialTotalSupply: number | BN | string,
      decimals: number | BN | string,
      fixedFees: {
        amount: number | BN | string;
        tokenId: string;
        useHbarsForPayment: boolean;
        useCurrentTokenForPayment: boolean;
        feeCollector: string;
      }[],
      fractionalFees: {
        numerator: number | BN | string;
        denominator: number | BN | string;
        minimumAmount: number | BN | string;
        maximumAmount: number | BN | string;
        netOfTransfers: boolean;
        feeCollector: string;
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  createNonFungibleToken: {
    (
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      txDetails?: Truffle.TransactionDetails
    ): Promise<{ 0: BN; 1: string }>;
    sendTransaction(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  createNonFungibleTokenWithCustomFees: {
    (
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      fixedFees: {
        amount: number | BN | string;
        tokenId: string;
        useHbarsForPayment: boolean;
        useCurrentTokenForPayment: boolean;
        feeCollector: string;
      }[],
      royaltyFees: {
        numerator: number | BN | string;
        denominator: number | BN | string;
        amount: number | BN | string;
        tokenId: string;
        useHbarsForPayment: boolean;
        feeCollector: string;
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      fixedFees: {
        amount: number | BN | string;
        tokenId: string;
        useHbarsForPayment: boolean;
        useCurrentTokenForPayment: boolean;
        feeCollector: string;
      }[],
      royaltyFees: {
        numerator: number | BN | string;
        denominator: number | BN | string;
        amount: number | BN | string;
        tokenId: string;
        useHbarsForPayment: boolean;
        feeCollector: string;
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<{ 0: BN; 1: string }>;
    sendTransaction(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      fixedFees: {
        amount: number | BN | string;
        tokenId: string;
        useHbarsForPayment: boolean;
        useCurrentTokenForPayment: boolean;
        feeCollector: string;
      }[],
      royaltyFees: {
        numerator: number | BN | string;
        denominator: number | BN | string;
        amount: number | BN | string;
        tokenId: string;
        useHbarsForPayment: boolean;
        feeCollector: string;
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      fixedFees: {
        amount: number | BN | string;
        tokenId: string;
        useHbarsForPayment: boolean;
        useCurrentTokenForPayment: boolean;
        feeCollector: string;
      }[],
      royaltyFees: {
        numerator: number | BN | string;
        denominator: number | BN | string;
        amount: number | BN | string;
        tokenId: string;
        useHbarsForPayment: boolean;
        feeCollector: string;
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Initiates a Fungible Token Transfer
   * @param accountId account to do a transfer to/from
   * @param amount The amount from the accountId at the same index
   * @param token The ID of the token as a solidity address
   */
  transferTokens: {
    (
      token: string,
      accountId: string[],
      amount: (number | BN | string)[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      accountId: string[],
      amount: (number | BN | string)[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      token: string,
      accountId: string[],
      amount: (number | BN | string)[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      accountId: string[],
      amount: (number | BN | string)[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Initiates a Non-Fungable Token Transfer
   * @param receiver the receiver of the nft sent by the same index at sender
   * @param sender the sender of an nft
   * @param serialNumber the serial number of the nft sent by the same index at sender
   * @param token The ID of the token as a solidity address
   */
  transferNFTs: {
    (
      token: string,
      sender: string[],
      receiver: string[],
      serialNumber: (number | BN | string)[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      sender: string[],
      receiver: string[],
      serialNumber: (number | BN | string)[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      token: string,
      sender: string[],
      receiver: string[],
      serialNumber: (number | BN | string)[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      sender: string[],
      receiver: string[],
      serialNumber: (number | BN | string)[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list, where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending (positive amount) or receiving (negative amount)
   * @param amount Non-negative value to send. a negative value will result in a failure.
   * @param recipient The receiver of the transaction
   * @param sender The sender for the transaction
   * @param token The token to transfer to/from
   */
  transferToken: {
    (
      token: string,
      sender: string,
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      sender: string,
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      token: string,
      sender: string,
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      sender: string,
      recipient: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list, where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending (positive amount) or receiving (negative amount)
   * @param recipient The receiver of the transaction
   * @param sender The sender for the transaction
   * @param serialNumber The serial number of the NFT to transfer.
   * @param token The token to transfer to/from
   */
  transferNFT: {
    (
      token: string,
      sender: string,
      recipient: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      sender: string,
      recipient: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      token: string,
      sender: string,
      recipient: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      sender: string,
      recipient: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Allows spender to withdraw from your account multiple times, up to the value amount. If this function is called again it overwrites the current allowance with value. Only Applicable to Fungible Tokens
   * @param amount the amount of tokens authorized to spend.
   * @param spender the account address authorized to spend
   * @param token The hedera token address to approve
   */
  approve: {
    (
      token: string,
      spender: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      spender: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      token: string,
      spender: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      spender: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Only applicable to fungible tokens
   * @param amount The amount of tokens to transfer from `from` to `to`
   * @param from The account address of the owner of the token, on the behalf of which to transfer `amount` tokens
   * @param to The account address of the receiver of the `amount` tokens
   * @param token The address of the fungible Hedera token to transfer
   */
  transferFrom: {
    (
      token: string,
      from: string,
      to: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      from: string,
      to: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      token: string,
      from: string,
      to: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      from: string,
      to: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Returns the amount which spender is still allowed to withdraw from owner. Only Applicable to Fungible Tokens
   * @param owner the owner of the tokens to be spent
   * @param spender the spender of the tokens
   * @param token The Hedera token address to check the allowance of
   */
  allowance: {
    (
      token: string,
      owner: string,
      spender: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      owner: string,
      spender: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{ 0: BN; 1: BN }>;
    sendTransaction(
      token: string,
      owner: string,
      spender: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      owner: string,
      spender: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Allow or reaffirm the approved address to transfer an NFT the approved address does not own. Only Applicable to NFT Tokens
   * @param approved The new approved NFT controller.  To revoke approvals pass in the zero address.
   * @param serialNumber The NFT serial number  to approve
   * @param token The Hedera NFT token address to approve
   */
  approveNFT: {
    (
      token: string,
      approved: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      approved: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      token: string,
      approved: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      approved: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Transfers `serialNumber` of `token` from `from` to `to` using the allowance mechanism. Only applicable to NFT tokens
   * @param from The account address of the owner of `serialNumber` of `token`
   * @param serialNumber The NFT serial number to transfer
   * @param to The account address of the receiver of `serialNumber`
   * @param token The address of the non-fungible Hedera token to transfer
   */
  transferFromNFT: {
    (
      token: string,
      from: string,
      to: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      from: string,
      to: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      token: string,
      from: string,
      to: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      from: string,
      to: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Get the approved address for a single NFT Only Applicable to NFT Tokens
   * @param serialNumber The NFT to find the approved address for
   * @param token The Hedera NFT token address to check approval
   */
  getApproved: {
    (
      token: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{ 0: BN; 1: string }>;
    sendTransaction(
      token: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Enable or disable approval for a third party ("operator") to manage  all of `msg.sender`'s assets
   * @param approved True if the operator is approved, false to revoke approval
   * @param operator Address to add to the set of authorized operators
   * @param token The Hedera NFT token address to approve
   */
  setApprovalForAll: {
    (
      token: string,
      operator: string,
      approved: boolean,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      operator: string,
      approved: boolean,
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      token: string,
      operator: string,
      approved: boolean,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      operator: string,
      approved: boolean,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Query if an address is an authorized operator for another address Only Applicable to NFT Tokens
   * @param operator The address that acts on behalf of the owner
   * @param owner The address that owns the NFTs
   * @param token The Hedera NFT token address to approve
   */
  isApprovedForAll: {
    (
      token: string,
      owner: string,
      operator: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      owner: string,
      operator: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{ 0: BN; 1: boolean }>;
    sendTransaction(
      token: string,
      owner: string,
      operator: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      owner: string,
      operator: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Query if token account is frozen
   * @param account The account address associated with the token
   * @param token The token address to check
   */
  isFrozen: {
    (
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{ 0: BN; 1: boolean }>;
    sendTransaction(
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Query if token account has kyc granted
   * @param account The account address associated with the token
   * @param token The token address to check
   */
  isKyc: {
    (
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{ 0: BN; 1: boolean }>;
    sendTransaction(
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Operation to delete token
   * @param token The token address to be deleted
   */
  deleteToken: {
    (token: string, txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(token: string, txDetails?: Truffle.TransactionDetails): Promise<BN>;
    sendTransaction(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Query token custom fees
   * @param token The token address to check
   */
  getTokenCustomFees: {
    (token: string, txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{
      0: BN;
      1: {
        amount: BN;
        tokenId: string;
        useHbarsForPayment: boolean;
        useCurrentTokenForPayment: boolean;
        feeCollector: string;
      }[];
      2: {
        numerator: BN;
        denominator: BN;
        minimumAmount: BN;
        maximumAmount: BN;
        netOfTransfers: boolean;
        feeCollector: string;
      }[];
      3: {
        numerator: BN;
        denominator: BN;
        amount: BN;
        tokenId: string;
        useHbarsForPayment: boolean;
        feeCollector: string;
      }[];
    }>;
    sendTransaction(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Query token default freeze status
   * @param token The token address to check
   */
  getTokenDefaultFreezeStatus: {
    (token: string, txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{ 0: BN; 1: boolean }>;
    sendTransaction(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Query token default kyc status
   * @param token The token address to check
   */
  getTokenDefaultKycStatus: {
    (token: string, txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{ 0: BN; 1: boolean }>;
    sendTransaction(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Query token expiry info
   * @param token The token address to check
   */
  getTokenExpiryInfo: {
    (token: string, txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{
      0: BN;
      1: { second: BN; autoRenewAccount: string; autoRenewPeriod: BN };
    }>;
    sendTransaction(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Query fungible token info
   * @param token The token address to check
   */
  getFungibleTokenInfo: {
    (token: string, txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{
      0: BN;
      1: {
        tokenInfo: {
          token: {
            name: string;
            symbol: string;
            treasury: string;
            memo: string;
            tokenSupplyType: boolean;
            maxSupply: BN;
            freezeDefault: boolean;
            tokenKeys: {
              keyType: BN;
              key: {
                inheritAccountKey: boolean;
                contractId: string;
                ed25519: string;
                ECDSA_secp256k1: string;
                delegatableContractId: string;
              };
            }[];
            expiry: {
              second: BN;
              autoRenewAccount: string;
              autoRenewPeriod: BN;
            };
          };
          totalSupply: BN;
          deleted: boolean;
          defaultKycStatus: boolean;
          pauseStatus: boolean;
          fixedFees: {
            amount: BN;
            tokenId: string;
            useHbarsForPayment: boolean;
            useCurrentTokenForPayment: boolean;
            feeCollector: string;
          }[];
          fractionalFees: {
            numerator: BN;
            denominator: BN;
            minimumAmount: BN;
            maximumAmount: BN;
            netOfTransfers: boolean;
            feeCollector: string;
          }[];
          royaltyFees: {
            numerator: BN;
            denominator: BN;
            amount: BN;
            tokenId: string;
            useHbarsForPayment: boolean;
            feeCollector: string;
          }[];
          ledgerId: string;
        };
        decimals: BN;
      };
    }>;
    sendTransaction(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Query token info
   * @param token The token address to check
   */
  getTokenInfo: {
    (token: string, txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{
      0: BN;
      1: {
        token: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: BN;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: BN;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: { second: BN; autoRenewAccount: string; autoRenewPeriod: BN };
        };
        totalSupply: BN;
        deleted: boolean;
        defaultKycStatus: boolean;
        pauseStatus: boolean;
        fixedFees: {
          amount: BN;
          tokenId: string;
          useHbarsForPayment: boolean;
          useCurrentTokenForPayment: boolean;
          feeCollector: string;
        }[];
        fractionalFees: {
          numerator: BN;
          denominator: BN;
          minimumAmount: BN;
          maximumAmount: BN;
          netOfTransfers: boolean;
          feeCollector: string;
        }[];
        royaltyFees: {
          numerator: BN;
          denominator: BN;
          amount: BN;
          tokenId: string;
          useHbarsForPayment: boolean;
          feeCollector: string;
        }[];
        ledgerId: string;
      };
    }>;
    sendTransaction(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Query token KeyValue
   * @param keyType The keyType of the desired KeyValue
   * @param token The token address to check
   */
  getTokenKey: {
    (
      token: string,
      keyType: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      keyType: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{
      0: BN;
      1: {
        inheritAccountKey: boolean;
        contractId: string;
        ed25519: string;
        ECDSA_secp256k1: string;
        delegatableContractId: string;
      };
    }>;
    sendTransaction(
      token: string,
      keyType: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      keyType: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Query non fungible token info
   * @param serialNumber The NFT serialNumber to check
   * @param token The token address to check
   */
  getNonFungibleTokenInfo: {
    (
      token: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{
      0: BN;
      1: {
        tokenInfo: {
          token: {
            name: string;
            symbol: string;
            treasury: string;
            memo: string;
            tokenSupplyType: boolean;
            maxSupply: BN;
            freezeDefault: boolean;
            tokenKeys: {
              keyType: BN;
              key: {
                inheritAccountKey: boolean;
                contractId: string;
                ed25519: string;
                ECDSA_secp256k1: string;
                delegatableContractId: string;
              };
            }[];
            expiry: {
              second: BN;
              autoRenewAccount: string;
              autoRenewPeriod: BN;
            };
          };
          totalSupply: BN;
          deleted: boolean;
          defaultKycStatus: boolean;
          pauseStatus: boolean;
          fixedFees: {
            amount: BN;
            tokenId: string;
            useHbarsForPayment: boolean;
            useCurrentTokenForPayment: boolean;
            feeCollector: string;
          }[];
          fractionalFees: {
            numerator: BN;
            denominator: BN;
            minimumAmount: BN;
            maximumAmount: BN;
            netOfTransfers: boolean;
            feeCollector: string;
          }[];
          royaltyFees: {
            numerator: BN;
            denominator: BN;
            amount: BN;
            tokenId: string;
            useHbarsForPayment: boolean;
            feeCollector: string;
          }[];
          ledgerId: string;
        };
        serialNumber: BN;
        ownerId: string;
        creationTime: BN;
        metadata: string;
        spenderId: string;
      };
    }>;
    sendTransaction(
      token: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      serialNumber: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Operation to freeze token account
   * @param account The account address to be frozen
   * @param token The token address
   */
  freezeToken: {
    (
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Operation to unfreeze token account
   * @param account The account address to be unfrozen
   * @param token The token address
   */
  unfreezeToken: {
    (
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Operation to grant kyc to token account
   * @param account The account address to grant kyc
   * @param token The token address
   */
  grantTokenKyc: {
    (
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Operation to revoke kyc to token account
   * @param account The account address to revoke kyc
   * @param token The token address
   */
  revokeTokenKyc: {
    (
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      account: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Operation to pause token
   * @param token The token address to be paused
   */
  pauseToken: {
    (token: string, txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(token: string, txDetails?: Truffle.TransactionDetails): Promise<BN>;
    sendTransaction(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Operation to unpause token
   * @param token The token address to be unpaused
   */
  unpauseToken: {
    (token: string, txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(token: string, txDetails?: Truffle.TransactionDetails): Promise<BN>;
    sendTransaction(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Operation to wipe fungible tokens from account
   * @param account The account address to revoke kyc
   * @param amount The number of tokens to wipe
   * @param token The token address
   */
  wipeTokenAccount: {
    (
      token: string,
      account: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      account: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      token: string,
      account: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      account: string,
      amount: number | BN | string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Operation to wipe non fungible tokens from account
   * @param account The account address to revoke kyc
   * @param serialNumbers The serial numbers of token to wipe
   * @param token The token address
   */
  wipeTokenAccountNFT: {
    (
      token: string,
      account: string,
      serialNumbers: (number | BN | string)[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      account: string,
      serialNumbers: (number | BN | string)[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      token: string,
      account: string,
      serialNumbers: (number | BN | string)[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      account: string,
      serialNumbers: (number | BN | string)[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  updateTokenInfo: {
    (
      token: string,
      tokenInfo: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      tokenInfo: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      token: string,
      tokenInfo: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      tokenInfo: {
        name: string;
        symbol: string;
        treasury: string;
        memo: string;
        tokenSupplyType: boolean;
        maxSupply: number | BN | string;
        freezeDefault: boolean;
        tokenKeys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[];
        expiry: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        };
      },
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  updateTokenExpiryInfo: {
    (
      token: string,
      expiryInfo: {
        second: number | BN | string;
        autoRenewAccount: string;
        autoRenewPeriod: number | BN | string;
      },
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      expiryInfo: {
        second: number | BN | string;
        autoRenewAccount: string;
        autoRenewPeriod: number | BN | string;
      },
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      token: string,
      expiryInfo: {
        second: number | BN | string;
        autoRenewAccount: string;
        autoRenewPeriod: number | BN | string;
      },
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      expiryInfo: {
        second: number | BN | string;
        autoRenewAccount: string;
        autoRenewPeriod: number | BN | string;
      },
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  updateTokenKeys: {
    (
      token: string,
      keys: {
        keyType: number | BN | string;
        key: {
          inheritAccountKey: boolean;
          contractId: string;
          ed25519: string;
          ECDSA_secp256k1: string;
          delegatableContractId: string;
        };
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<Truffle.TransactionResponse<AllEvents>>;
    call(
      token: string,
      keys: {
        keyType: number | BN | string;
        key: {
          inheritAccountKey: boolean;
          contractId: string;
          ed25519: string;
          ECDSA_secp256k1: string;
          delegatableContractId: string;
        };
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<BN>;
    sendTransaction(
      token: string,
      keys: {
        keyType: number | BN | string;
        key: {
          inheritAccountKey: boolean;
          contractId: string;
          ed25519: string;
          ECDSA_secp256k1: string;
          delegatableContractId: string;
        };
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      keys: {
        keyType: number | BN | string;
        key: {
          inheritAccountKey: boolean;
          contractId: string;
          ed25519: string;
          ECDSA_secp256k1: string;
          delegatableContractId: string;
        };
      }[],
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Query if valid token found for the given address
   * @param token The token address
   */
  isToken: {
    (token: string, txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{ 0: BN; 1: boolean }>;
    sendTransaction(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  /**
   * Query to return the token type for a given address
   * @param token The token address
   */
  getTokenType: {
    (token: string, txDetails?: Truffle.TransactionDetails): Promise<
      Truffle.TransactionResponse<AllEvents>
    >;
    call(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<{ 0: BN; 1: BN }>;
    sendTransaction(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<string>;
    estimateGas(
      token: string,
      txDetails?: Truffle.TransactionDetails
    ): Promise<number>;
  };

  methods: {
    cryptoTransfer: {
      (
        tokenTransfers: {
          token: string;
          transfers: { accountID: string; amount: number | BN | string }[];
          nftTransfers: {
            senderAccountID: string;
            receiverAccountID: string;
            serialNumber: number | BN | string;
          }[];
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        tokenTransfers: {
          token: string;
          transfers: { accountID: string; amount: number | BN | string }[];
          nftTransfers: {
            senderAccountID: string;
            receiverAccountID: string;
            serialNumber: number | BN | string;
          }[];
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        tokenTransfers: {
          token: string;
          transfers: { accountID: string; amount: number | BN | string }[];
          nftTransfers: {
            senderAccountID: string;
            receiverAccountID: string;
            serialNumber: number | BN | string;
          }[];
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        tokenTransfers: {
          token: string;
          transfers: { accountID: string; amount: number | BN | string }[];
          nftTransfers: {
            senderAccountID: string;
            receiverAccountID: string;
            serialNumber: number | BN | string;
          }[];
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Mints an amount of the token to the defined treasury account
     * @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.               Amount must be a positive non-zero number represented in the lowest denomination of the               token. The new supply must be lower than 2^63.
     * @param metadata Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.                 Maximum allowed size of each metadata is 100 bytes
     * @param token The token for which to mint tokens. If token does not exist, transaction results in              INVALID_TOKEN_ID
     */
    mintToken: {
      (
        token: string,
        amount: number | BN | string,
        metadata: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        amount: number | BN | string,
        metadata: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<{ 0: BN; 1: BN; 2: BN[] }>;
      sendTransaction(
        token: string,
        amount: number | BN | string,
        metadata: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        amount: number | BN | string,
        metadata: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Burns an amount of the token from the defined treasury account
     * @param amount Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.                Amount must be a positive non-zero number, not bigger than the token balance of the treasury                account (0; balance], represented in the lowest denomination.
     * @param serialNumbers Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.
     * @param token The token for which to burn tokens. If token does not exist, transaction results in              INVALID_TOKEN_ID
     */
    burnToken: {
      (
        token: string,
        amount: number | BN | string,
        serialNumbers: (number | BN | string)[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        amount: number | BN | string,
        serialNumbers: (number | BN | string)[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<{ 0: BN; 1: BN }>;
      sendTransaction(
        token: string,
        amount: number | BN | string,
        serialNumbers: (number | BN | string)[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        amount: number | BN | string,
        serialNumbers: (number | BN | string)[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Associates the provided account with the provided tokens. Must be signed by the provided  Account's key or called from the accounts contract key  If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.  If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.  If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.  If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.  If an association between the provided account and any of the tokens already exists, the  transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.  If the provided account's associations count exceed the constraint of maximum token associations    per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.  On success, associations between the provided account and tokens are made and the account is    ready to interact with the tokens.
     * @param account The account to be associated with the provided tokens
     * @param tokens The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE               Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that               token type
     */
    associateTokens: {
      (
        account: string,
        tokens: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        account: string,
        tokens: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        account: string,
        tokens: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        account: string,
        tokens: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Single-token variant of associateTokens. Will be mapped to a single entry array call of associateTokens
     * @param account The account to be associated with the provided token
     * @param token The token to be associated with the provided account
     */
    associateToken: {
      (
        account: string,
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        account: string,
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        account: string,
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        account: string,
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Dissociates the provided account with the provided tokens. Must be signed by the provided Account's key. If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID. If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED. If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF. If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED. If an association between the provided account and any of the tokens does not exist, the transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT. If a token has not been deleted and has not expired, and the user has a nonzero balance, the transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES. If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is not zero. If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES. On success, associations between the provided account and tokens are removed.
     * @param account The account to be dissociated from the provided tokens
     * @param tokens The tokens to be dissociated from the provided account.
     */
    dissociateTokens: {
      (
        account: string,
        tokens: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        account: string,
        tokens: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        account: string,
        tokens: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        account: string,
        tokens: string[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Single-token variant of dissociateTokens. Will be mapped to a single entry array call of dissociateTokens
     * @param account The account to be associated with the provided token
     * @param token The token to be associated with the provided account
     */
    dissociateToken: {
      (
        account: string,
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        account: string,
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        account: string,
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        account: string,
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    createFungibleToken: {
      (
        token: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        initialTotalSupply: number | BN | string,
        decimals: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        initialTotalSupply: number | BN | string,
        decimals: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<{ 0: BN; 1: string }>;
      sendTransaction(
        token: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        initialTotalSupply: number | BN | string,
        decimals: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        initialTotalSupply: number | BN | string,
        decimals: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    createFungibleTokenWithCustomFees: {
      (
        token: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        initialTotalSupply: number | BN | string,
        decimals: number | BN | string,
        fixedFees: {
          amount: number | BN | string;
          tokenId: string;
          useHbarsForPayment: boolean;
          useCurrentTokenForPayment: boolean;
          feeCollector: string;
        }[],
        fractionalFees: {
          numerator: number | BN | string;
          denominator: number | BN | string;
          minimumAmount: number | BN | string;
          maximumAmount: number | BN | string;
          netOfTransfers: boolean;
          feeCollector: string;
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        initialTotalSupply: number | BN | string,
        decimals: number | BN | string,
        fixedFees: {
          amount: number | BN | string;
          tokenId: string;
          useHbarsForPayment: boolean;
          useCurrentTokenForPayment: boolean;
          feeCollector: string;
        }[],
        fractionalFees: {
          numerator: number | BN | string;
          denominator: number | BN | string;
          minimumAmount: number | BN | string;
          maximumAmount: number | BN | string;
          netOfTransfers: boolean;
          feeCollector: string;
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<{ 0: BN; 1: string }>;
      sendTransaction(
        token: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        initialTotalSupply: number | BN | string,
        decimals: number | BN | string,
        fixedFees: {
          amount: number | BN | string;
          tokenId: string;
          useHbarsForPayment: boolean;
          useCurrentTokenForPayment: boolean;
          feeCollector: string;
        }[],
        fractionalFees: {
          numerator: number | BN | string;
          denominator: number | BN | string;
          minimumAmount: number | BN | string;
          maximumAmount: number | BN | string;
          netOfTransfers: boolean;
          feeCollector: string;
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        initialTotalSupply: number | BN | string,
        decimals: number | BN | string,
        fixedFees: {
          amount: number | BN | string;
          tokenId: string;
          useHbarsForPayment: boolean;
          useCurrentTokenForPayment: boolean;
          feeCollector: string;
        }[],
        fractionalFees: {
          numerator: number | BN | string;
          denominator: number | BN | string;
          minimumAmount: number | BN | string;
          maximumAmount: number | BN | string;
          netOfTransfers: boolean;
          feeCollector: string;
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    createNonFungibleToken: {
      (
        token: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        txDetails?: Truffle.TransactionDetails
      ): Promise<{ 0: BN; 1: string }>;
      sendTransaction(
        token: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    createNonFungibleTokenWithCustomFees: {
      (
        token: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        fixedFees: {
          amount: number | BN | string;
          tokenId: string;
          useHbarsForPayment: boolean;
          useCurrentTokenForPayment: boolean;
          feeCollector: string;
        }[],
        royaltyFees: {
          numerator: number | BN | string;
          denominator: number | BN | string;
          amount: number | BN | string;
          tokenId: string;
          useHbarsForPayment: boolean;
          feeCollector: string;
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        fixedFees: {
          amount: number | BN | string;
          tokenId: string;
          useHbarsForPayment: boolean;
          useCurrentTokenForPayment: boolean;
          feeCollector: string;
        }[],
        royaltyFees: {
          numerator: number | BN | string;
          denominator: number | BN | string;
          amount: number | BN | string;
          tokenId: string;
          useHbarsForPayment: boolean;
          feeCollector: string;
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<{ 0: BN; 1: string }>;
      sendTransaction(
        token: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        fixedFees: {
          amount: number | BN | string;
          tokenId: string;
          useHbarsForPayment: boolean;
          useCurrentTokenForPayment: boolean;
          feeCollector: string;
        }[],
        royaltyFees: {
          numerator: number | BN | string;
          denominator: number | BN | string;
          amount: number | BN | string;
          tokenId: string;
          useHbarsForPayment: boolean;
          feeCollector: string;
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        fixedFees: {
          amount: number | BN | string;
          tokenId: string;
          useHbarsForPayment: boolean;
          useCurrentTokenForPayment: boolean;
          feeCollector: string;
        }[],
        royaltyFees: {
          numerator: number | BN | string;
          denominator: number | BN | string;
          amount: number | BN | string;
          tokenId: string;
          useHbarsForPayment: boolean;
          feeCollector: string;
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Initiates a Fungible Token Transfer
     * @param accountId account to do a transfer to/from
     * @param amount The amount from the accountId at the same index
     * @param token The ID of the token as a solidity address
     */
    transferTokens: {
      (
        token: string,
        accountId: string[],
        amount: (number | BN | string)[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        accountId: string[],
        amount: (number | BN | string)[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        token: string,
        accountId: string[],
        amount: (number | BN | string)[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        accountId: string[],
        amount: (number | BN | string)[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Initiates a Non-Fungable Token Transfer
     * @param receiver the receiver of the nft sent by the same index at sender
     * @param sender the sender of an nft
     * @param serialNumber the serial number of the nft sent by the same index at sender
     * @param token The ID of the token as a solidity address
     */
    transferNFTs: {
      (
        token: string,
        sender: string[],
        receiver: string[],
        serialNumber: (number | BN | string)[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        sender: string[],
        receiver: string[],
        serialNumber: (number | BN | string)[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        token: string,
        sender: string[],
        receiver: string[],
        serialNumber: (number | BN | string)[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        sender: string[],
        receiver: string[],
        serialNumber: (number | BN | string)[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list, where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending (positive amount) or receiving (negative amount)
     * @param amount Non-negative value to send. a negative value will result in a failure.
     * @param recipient The receiver of the transaction
     * @param sender The sender for the transaction
     * @param token The token to transfer to/from
     */
    transferToken: {
      (
        token: string,
        sender: string,
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        sender: string,
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        token: string,
        sender: string,
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        sender: string,
        recipient: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Transfers tokens where the calling account/contract is implicitly the first entry in the token transfer list, where the amount is the value needed to zero balance the transfers. Regular signing rules apply for sending (positive amount) or receiving (negative amount)
     * @param recipient The receiver of the transaction
     * @param sender The sender for the transaction
     * @param serialNumber The serial number of the NFT to transfer.
     * @param token The token to transfer to/from
     */
    transferNFT: {
      (
        token: string,
        sender: string,
        recipient: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        sender: string,
        recipient: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        token: string,
        sender: string,
        recipient: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        sender: string,
        recipient: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Allows spender to withdraw from your account multiple times, up to the value amount. If this function is called again it overwrites the current allowance with value. Only Applicable to Fungible Tokens
     * @param amount the amount of tokens authorized to spend.
     * @param spender the account address authorized to spend
     * @param token The hedera token address to approve
     */
    approve: {
      (
        token: string,
        spender: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        spender: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        token: string,
        spender: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        spender: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Only applicable to fungible tokens
     * @param amount The amount of tokens to transfer from `from` to `to`
     * @param from The account address of the owner of the token, on the behalf of which to transfer `amount` tokens
     * @param to The account address of the receiver of the `amount` tokens
     * @param token The address of the fungible Hedera token to transfer
     */
    transferFrom: {
      (
        token: string,
        from: string,
        to: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        from: string,
        to: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        token: string,
        from: string,
        to: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        from: string,
        to: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Returns the amount which spender is still allowed to withdraw from owner. Only Applicable to Fungible Tokens
     * @param owner the owner of the tokens to be spent
     * @param spender the spender of the tokens
     * @param token The Hedera token address to check the allowance of
     */
    allowance: {
      (
        token: string,
        owner: string,
        spender: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        owner: string,
        spender: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<{ 0: BN; 1: BN }>;
      sendTransaction(
        token: string,
        owner: string,
        spender: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        owner: string,
        spender: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Allow or reaffirm the approved address to transfer an NFT the approved address does not own. Only Applicable to NFT Tokens
     * @param approved The new approved NFT controller.  To revoke approvals pass in the zero address.
     * @param serialNumber The NFT serial number  to approve
     * @param token The Hedera NFT token address to approve
     */
    approveNFT: {
      (
        token: string,
        approved: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        approved: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        token: string,
        approved: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        approved: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Transfers `serialNumber` of `token` from `from` to `to` using the allowance mechanism. Only applicable to NFT tokens
     * @param from The account address of the owner of `serialNumber` of `token`
     * @param serialNumber The NFT serial number to transfer
     * @param to The account address of the receiver of `serialNumber`
     * @param token The address of the non-fungible Hedera token to transfer
     */
    transferFromNFT: {
      (
        token: string,
        from: string,
        to: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        from: string,
        to: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        token: string,
        from: string,
        to: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        from: string,
        to: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Get the approved address for a single NFT Only Applicable to NFT Tokens
     * @param serialNumber The NFT to find the approved address for
     * @param token The Hedera NFT token address to check approval
     */
    getApproved: {
      (
        token: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<{ 0: BN; 1: string }>;
      sendTransaction(
        token: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Enable or disable approval for a third party ("operator") to manage  all of `msg.sender`'s assets
     * @param approved True if the operator is approved, false to revoke approval
     * @param operator Address to add to the set of authorized operators
     * @param token The Hedera NFT token address to approve
     */
    setApprovalForAll: {
      (
        token: string,
        operator: string,
        approved: boolean,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        operator: string,
        approved: boolean,
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        token: string,
        operator: string,
        approved: boolean,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        operator: string,
        approved: boolean,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Query if an address is an authorized operator for another address Only Applicable to NFT Tokens
     * @param operator The address that acts on behalf of the owner
     * @param owner The address that owns the NFTs
     * @param token The Hedera NFT token address to approve
     */
    isApprovedForAll: {
      (
        token: string,
        owner: string,
        operator: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        owner: string,
        operator: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<{ 0: BN; 1: boolean }>;
      sendTransaction(
        token: string,
        owner: string,
        operator: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        owner: string,
        operator: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Query if token account is frozen
     * @param account The account address associated with the token
     * @param token The token address to check
     */
    isFrozen: {
      (
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<{ 0: BN; 1: boolean }>;
      sendTransaction(
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Query if token account has kyc granted
     * @param account The account address associated with the token
     * @param token The token address to check
     */
    isKyc: {
      (
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<{ 0: BN; 1: boolean }>;
      sendTransaction(
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Operation to delete token
     * @param token The token address to be deleted
     */
    deleteToken: {
      (token: string, txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(token: string, txDetails?: Truffle.TransactionDetails): Promise<BN>;
      sendTransaction(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Query token custom fees
     * @param token The token address to check
     */
    getTokenCustomFees: {
      (token: string, txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<{
        0: BN;
        1: {
          amount: BN;
          tokenId: string;
          useHbarsForPayment: boolean;
          useCurrentTokenForPayment: boolean;
          feeCollector: string;
        }[];
        2: {
          numerator: BN;
          denominator: BN;
          minimumAmount: BN;
          maximumAmount: BN;
          netOfTransfers: boolean;
          feeCollector: string;
        }[];
        3: {
          numerator: BN;
          denominator: BN;
          amount: BN;
          tokenId: string;
          useHbarsForPayment: boolean;
          feeCollector: string;
        }[];
      }>;
      sendTransaction(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Query token default freeze status
     * @param token The token address to check
     */
    getTokenDefaultFreezeStatus: {
      (token: string, txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<{ 0: BN; 1: boolean }>;
      sendTransaction(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Query token default kyc status
     * @param token The token address to check
     */
    getTokenDefaultKycStatus: {
      (token: string, txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<{ 0: BN; 1: boolean }>;
      sendTransaction(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Query token expiry info
     * @param token The token address to check
     */
    getTokenExpiryInfo: {
      (token: string, txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<{
        0: BN;
        1: { second: BN; autoRenewAccount: string; autoRenewPeriod: BN };
      }>;
      sendTransaction(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Query fungible token info
     * @param token The token address to check
     */
    getFungibleTokenInfo: {
      (token: string, txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<{
        0: BN;
        1: {
          tokenInfo: {
            token: {
              name: string;
              symbol: string;
              treasury: string;
              memo: string;
              tokenSupplyType: boolean;
              maxSupply: BN;
              freezeDefault: boolean;
              tokenKeys: {
                keyType: BN;
                key: {
                  inheritAccountKey: boolean;
                  contractId: string;
                  ed25519: string;
                  ECDSA_secp256k1: string;
                  delegatableContractId: string;
                };
              }[];
              expiry: {
                second: BN;
                autoRenewAccount: string;
                autoRenewPeriod: BN;
              };
            };
            totalSupply: BN;
            deleted: boolean;
            defaultKycStatus: boolean;
            pauseStatus: boolean;
            fixedFees: {
              amount: BN;
              tokenId: string;
              useHbarsForPayment: boolean;
              useCurrentTokenForPayment: boolean;
              feeCollector: string;
            }[];
            fractionalFees: {
              numerator: BN;
              denominator: BN;
              minimumAmount: BN;
              maximumAmount: BN;
              netOfTransfers: boolean;
              feeCollector: string;
            }[];
            royaltyFees: {
              numerator: BN;
              denominator: BN;
              amount: BN;
              tokenId: string;
              useHbarsForPayment: boolean;
              feeCollector: string;
            }[];
            ledgerId: string;
          };
          decimals: BN;
        };
      }>;
      sendTransaction(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Query token info
     * @param token The token address to check
     */
    getTokenInfo: {
      (token: string, txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<{
        0: BN;
        1: {
          token: {
            name: string;
            symbol: string;
            treasury: string;
            memo: string;
            tokenSupplyType: boolean;
            maxSupply: BN;
            freezeDefault: boolean;
            tokenKeys: {
              keyType: BN;
              key: {
                inheritAccountKey: boolean;
                contractId: string;
                ed25519: string;
                ECDSA_secp256k1: string;
                delegatableContractId: string;
              };
            }[];
            expiry: {
              second: BN;
              autoRenewAccount: string;
              autoRenewPeriod: BN;
            };
          };
          totalSupply: BN;
          deleted: boolean;
          defaultKycStatus: boolean;
          pauseStatus: boolean;
          fixedFees: {
            amount: BN;
            tokenId: string;
            useHbarsForPayment: boolean;
            useCurrentTokenForPayment: boolean;
            feeCollector: string;
          }[];
          fractionalFees: {
            numerator: BN;
            denominator: BN;
            minimumAmount: BN;
            maximumAmount: BN;
            netOfTransfers: boolean;
            feeCollector: string;
          }[];
          royaltyFees: {
            numerator: BN;
            denominator: BN;
            amount: BN;
            tokenId: string;
            useHbarsForPayment: boolean;
            feeCollector: string;
          }[];
          ledgerId: string;
        };
      }>;
      sendTransaction(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Query token KeyValue
     * @param keyType The keyType of the desired KeyValue
     * @param token The token address to check
     */
    getTokenKey: {
      (
        token: string,
        keyType: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        keyType: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<{
        0: BN;
        1: {
          inheritAccountKey: boolean;
          contractId: string;
          ed25519: string;
          ECDSA_secp256k1: string;
          delegatableContractId: string;
        };
      }>;
      sendTransaction(
        token: string,
        keyType: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        keyType: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Query non fungible token info
     * @param serialNumber The NFT serialNumber to check
     * @param token The token address to check
     */
    getNonFungibleTokenInfo: {
      (
        token: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<{
        0: BN;
        1: {
          tokenInfo: {
            token: {
              name: string;
              symbol: string;
              treasury: string;
              memo: string;
              tokenSupplyType: boolean;
              maxSupply: BN;
              freezeDefault: boolean;
              tokenKeys: {
                keyType: BN;
                key: {
                  inheritAccountKey: boolean;
                  contractId: string;
                  ed25519: string;
                  ECDSA_secp256k1: string;
                  delegatableContractId: string;
                };
              }[];
              expiry: {
                second: BN;
                autoRenewAccount: string;
                autoRenewPeriod: BN;
              };
            };
            totalSupply: BN;
            deleted: boolean;
            defaultKycStatus: boolean;
            pauseStatus: boolean;
            fixedFees: {
              amount: BN;
              tokenId: string;
              useHbarsForPayment: boolean;
              useCurrentTokenForPayment: boolean;
              feeCollector: string;
            }[];
            fractionalFees: {
              numerator: BN;
              denominator: BN;
              minimumAmount: BN;
              maximumAmount: BN;
              netOfTransfers: boolean;
              feeCollector: string;
            }[];
            royaltyFees: {
              numerator: BN;
              denominator: BN;
              amount: BN;
              tokenId: string;
              useHbarsForPayment: boolean;
              feeCollector: string;
            }[];
            ledgerId: string;
          };
          serialNumber: BN;
          ownerId: string;
          creationTime: BN;
          metadata: string;
          spenderId: string;
        };
      }>;
      sendTransaction(
        token: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        serialNumber: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Operation to freeze token account
     * @param account The account address to be frozen
     * @param token The token address
     */
    freezeToken: {
      (
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Operation to unfreeze token account
     * @param account The account address to be unfrozen
     * @param token The token address
     */
    unfreezeToken: {
      (
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Operation to grant kyc to token account
     * @param account The account address to grant kyc
     * @param token The token address
     */
    grantTokenKyc: {
      (
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Operation to revoke kyc to token account
     * @param account The account address to revoke kyc
     * @param token The token address
     */
    revokeTokenKyc: {
      (
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        account: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Operation to pause token
     * @param token The token address to be paused
     */
    pauseToken: {
      (token: string, txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(token: string, txDetails?: Truffle.TransactionDetails): Promise<BN>;
      sendTransaction(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Operation to unpause token
     * @param token The token address to be unpaused
     */
    unpauseToken: {
      (token: string, txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(token: string, txDetails?: Truffle.TransactionDetails): Promise<BN>;
      sendTransaction(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Operation to wipe fungible tokens from account
     * @param account The account address to revoke kyc
     * @param amount The number of tokens to wipe
     * @param token The token address
     */
    wipeTokenAccount: {
      (
        token: string,
        account: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        account: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        token: string,
        account: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        account: string,
        amount: number | BN | string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Operation to wipe non fungible tokens from account
     * @param account The account address to revoke kyc
     * @param serialNumbers The serial numbers of token to wipe
     * @param token The token address
     */
    wipeTokenAccountNFT: {
      (
        token: string,
        account: string,
        serialNumbers: (number | BN | string)[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        account: string,
        serialNumbers: (number | BN | string)[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        token: string,
        account: string,
        serialNumbers: (number | BN | string)[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        account: string,
        serialNumbers: (number | BN | string)[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    updateTokenInfo: {
      (
        token: string,
        tokenInfo: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        tokenInfo: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        token: string,
        tokenInfo: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        tokenInfo: {
          name: string;
          symbol: string;
          treasury: string;
          memo: string;
          tokenSupplyType: boolean;
          maxSupply: number | BN | string;
          freezeDefault: boolean;
          tokenKeys: {
            keyType: number | BN | string;
            key: {
              inheritAccountKey: boolean;
              contractId: string;
              ed25519: string;
              ECDSA_secp256k1: string;
              delegatableContractId: string;
            };
          }[];
          expiry: {
            second: number | BN | string;
            autoRenewAccount: string;
            autoRenewPeriod: number | BN | string;
          };
        },
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    updateTokenExpiryInfo: {
      (
        token: string,
        expiryInfo: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        },
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        expiryInfo: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        },
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        token: string,
        expiryInfo: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        },
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        expiryInfo: {
          second: number | BN | string;
          autoRenewAccount: string;
          autoRenewPeriod: number | BN | string;
        },
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    updateTokenKeys: {
      (
        token: string,
        keys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<Truffle.TransactionResponse<AllEvents>>;
      call(
        token: string,
        keys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<BN>;
      sendTransaction(
        token: string,
        keys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        keys: {
          keyType: number | BN | string;
          key: {
            inheritAccountKey: boolean;
            contractId: string;
            ed25519: string;
            ECDSA_secp256k1: string;
            delegatableContractId: string;
          };
        }[],
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Query if valid token found for the given address
     * @param token The token address
     */
    isToken: {
      (token: string, txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<{ 0: BN; 1: boolean }>;
      sendTransaction(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };

    /**
     * Query to return the token type for a given address
     * @param token The token address
     */
    getTokenType: {
      (token: string, txDetails?: Truffle.TransactionDetails): Promise<
        Truffle.TransactionResponse<AllEvents>
      >;
      call(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<{ 0: BN; 1: BN }>;
      sendTransaction(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<string>;
      estimateGas(
        token: string,
        txDetails?: Truffle.TransactionDetails
      ): Promise<number>;
    };
  };

  getPastEvents(event: string): Promise<EventData[]>;
  getPastEvents(
    event: string,
    options: PastEventOptions,
    callback: (error: Error, event: EventData) => void
  ): Promise<EventData[]>;
  getPastEvents(event: string, options: PastEventOptions): Promise<EventData[]>;
  getPastEvents(
    event: string,
    callback: (error: Error, event: EventData) => void
  ): Promise<EventData[]>;
}
